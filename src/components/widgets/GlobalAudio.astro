---
import musicJson from "@/data/music.json";
// 初始化用本地歌单（不阻塞渲染），完整歌单由客户端异步加载
const musicList = (musicJson as any[]) || [];
const initialPlaylist = JSON.stringify(musicList);
const initialSong = musicList[0] || {};
---
<div transition:persist="mahiro-global-audio-wrapper">
    <!-- 全局音频元素，持久化 -->
    <audio id="global-audio-player"></audio>

    <!-- 迷你播放器容器，只在非音乐页面显示 -->
    <div id="mini-player-container" class="fixed bottom-6 left-6 z-[999] flex items-end gap-3 pointer-events-none opacity-0 transition-opacity duration-300">
        
        <!-- 悬浮圆形按钮 (FAB) -->
        <div class="relative group pointer-events-auto">
            <!-- 环形进度条背景 -->
            <svg class="absolute -inset-1 w-[calc(100%+8px)] h-[calc(100%+8px)] -rotate-90 pointer-events-none opacity-50 transition-opacity group-hover:opacity-100" viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="48" fill="none" stroke="currentColor" stroke-width="4" class="text-base-300 dark:text-base-content/10" />
                <circle id="mini-progress-ring" cx="50" cy="50" r="48" fill="none" stroke="currentColor" stroke-width="4" stroke-dasharray="301.59" stroke-dashoffset="301.59" class="text-primary transition-all duration-300 ease-linear" stroke-linecap="round" />
            </svg>

            <button id="mini-fab" class="w-14 h-14 rounded-full bg-base-100/90 dark:bg-base-300/90 backdrop-blur-xl shadow-lg border border-base-content/5 flex items-center justify-center relative overflow-hidden transition-transform duration-300 hover:scale-105 active:scale-95 z-10">
                <div class="absolute inset-0 rounded-full animate-spin-slow" id="mini-fab-spin" style="animation-play-state: paused;">
                    <img id="mini-fab-cover" src={initialSong.cover || "/favicon.ico"} class="w-full h-full object-cover opacity-80" alt="cover"/>
                </div>
                <!-- 遮罩 & 图标 -->
                <div class="absolute inset-0 bg-base-content/20 dark:bg-black/40 flex items-center justify-center backdrop-blur-[2px] opacity-0 group-hover:opacity-100 transition-opacity duration-300">
                    <svg id="mini-fab-icon-play" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-white fill-white ml-1"><polygon points="5 3 19 12 5 21 5 3"/></svg>
                    <svg id="mini-fab-icon-pause" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-6 h-6 text-white fill-white hidden"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>
                </div>
                <!-- 播放中时的跳动音轨动画 (鼠标移开时显示) -->
                <div id="mini-fab-visualizer" class="absolute inset-0 flex items-center justify-center gap-0.5 bg-black/30 backdrop-blur-sm group-hover:hidden transition-opacity">
                    <div class="w-0.5 bg-white h-2 rounded-full transition-all duration-300"></div>
                    <div class="w-0.5 bg-white h-4 rounded-full transition-all duration-300"></div>
                    <div class="w-0.5 bg-white h-2.5 rounded-full transition-all duration-300"></div>
                    <div class="w-0.5 bg-white h-3.5 rounded-full transition-all duration-300"></div>
                </div>
            </button>
        </div>

        <!-- 展开的拉片框 (从 FAB 旁边滑出) -->
        <div id="mini-player-card" class="bg-base-100/90 dark:bg-base-300/90 backdrop-blur-xl h-14 pl-3 pr-2 rounded-full shadow-lg border border-base-content/5 flex items-center gap-3 w-56 -translate-x-full opacity-0 pointer-events-none transition-all duration-500 ease-\[cubic-bezier(0.23\,1\,0.32\,1)\] absolute left-16 z-0">
            <!-- 歌曲信息 -->
            <div class="flex flex-col justify-center min-w-0 flex-1 py-1">
                <a href="/music" class="font-bold text-base-content text-sm truncate leading-tight hover:text-primary transition-colors cursor-pointer" id="mini-title" title="Go to Music Page">{initialSong.title || "Mahiro"}</a>
                <p id="mini-artist" class="text-[10px] text-base-content/60 truncate uppercase tracking-wider">{initialSong.artist || "Music"}</p>
            </div>
            
            <!-- 控制按钮 -->
            <div class="flex items-center gap-1 shrink-0">
                <button id="mini-prev" class="w-8 h-8 rounded-full flex items-center justify-center text-base-content/70 hover:text-primary hover:bg-primary/10 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><polygon points="19 20 9 12 19 4 19 20"/><line x1="5" x2="5" y1="19" y2="5" stroke="currentColor" stroke-width="2"/></svg>
                </button>
                <button id="mini-next" class="w-8 h-8 rounded-full flex items-center justify-center text-base-content/70 hover:text-primary hover:bg-primary/10 transition-colors">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 4 15 12 5 20 5 4"/><line x1="19" x2="19" y1="5" y2="19" stroke="currentColor" stroke-width="2"/></svg>
                </button>
            </div>
        </div>
    </div>
</div>

<script define:vars={{ initialPlaylist }} is:inline>
    class GlobalMusicPlayer {
        constructor() {
            // Attempt to restore persistent playlist
            let savedPlaylist = null;
            try {
                const stored = localStorage.getItem('mahiro_music_playlist');
                if (stored) savedPlaylist = JSON.parse(stored);
            } catch(e) { console.warn("Failed to parse saved playlist"); }

            // Initial state
            let savedIndex = 0;
            try {
                const storedIdx = localStorage.getItem('mahiro_music_current_index');
                if (storedIdx !== null) savedIndex = parseInt(storedIdx, 10);
            } catch(e) {}

            this.playlist = (savedPlaylist && savedPlaylist.length > 0) ? savedPlaylist : JSON.parse(initialPlaylist);
            this.currentIndex = (savedIndex >= 0 && savedIndex < this.playlist.length) ? savedIndex : 0;
            this.isPlaying = false;
            this.isShuffle = false;
            // 'all' = Loop All (Sequential), 'one' = Loop One, 'off' = No Loop (Stop at end)
            this.repeatMode = 'all'; 
            this.lyrics = [];
            this.lrcUrl = "";
            this.lastActiveIndex = -1;
            this.isMiniOpen = false;
            this.hasBoundDocumentClick = false;
            this.closeTimer = null;
            this.isDraggingProgress = false;
            this.isDraggingVolume = false;

            // Initial binding
            this.handlePageLoad();

            // Load initial song if needed
            if (this.playlist.length > 0 && this.audio && !this.audio.src) {
               this.loadSong(0, false);
            }
            
            // Listen for future navigations
            document.addEventListener('astro:page-load', () => this.handlePageLoad());
        }

        handlePageLoad() {
            // Re-acquire all DOM references to handle persistence failures or DOM updates
            this.bindGlobalAudioEvents();
            this.bindMiniPlayerEvents();
            
            // Check for Main Player widget
            this.container = document.querySelector('.music-player-widget');
            if (this.container) {
                // Bind Main Player UI
                this.playBtn = document.getElementById('play-btn');
                this.prevBtn = document.getElementById('prev-btn');
                this.nextBtn = document.getElementById('next-btn');
                this.shuffleBtn = document.getElementById('shuffle-btn');
                this.repeatBtn = document.getElementById('repeat-btn');
                this.iconPlay = document.getElementById('icon-play');
                this.iconPause = document.getElementById('icon-pause');
                this.recordOuter = document.getElementById('record-outer');
                this.recordInner = document.getElementById('record-inner');
                this.needle = document.getElementById('player-needle');
                this.statusDot = document.getElementById('player-status-dot');
                this.statusText = document.getElementById('player-status-text');
                this.currentTimeEl = document.getElementById('current-time');
                this.totalTimeEl = document.getElementById('total-time');
                this.progressBar = document.getElementById('progress-bar');
                this.progressContainer = document.getElementById('progress-container');
                this.lyricsContainer = document.getElementById('lyrics-container');
                this.volumeControl = document.getElementById('volume-control');
                this.volumeBar = document.getElementById('volume-bar');
                this.btnPlaylist = document.getElementById('btn-show-playlist');
                this.btnLyrics = document.getElementById('btn-show-lyrics');
                this.playlistContainer = document.getElementById('playlist-container');
                this.playerTitle = document.getElementById('player-title');
                this.playerArtist = document.getElementById('player-artist');
                this.bgCover = document.getElementById('player-bg-cover');
                this.playerCover = document.getElementById('player-cover');
                
                this.bindUIEvents();
                // If we have lyrics loaded in memory, render them
                if (this.lyrics.length > 0 && this.lyricsContainer) {
                     this.renderLyrics();
                     this.syncLyrics(this.audio ? this.audio.currentTime : 0);
                } else if(this.lrcUrl) {
                    this.loadLyrics();
                }
                
                this.updatePlaylistDurations();
                this.bindPlaylistEvents();
            }

            // Sync playback status with audio element
            if (this.audio && !this.audio.paused) {
                 this.isPlaying = true;
            }

            // Update UI State (syncs both Mini and Main players)
            this.updateUI();

            // Handle Mini Player Visibility
            const path = window.location.pathname;
            const isMusicPage = path.includes('/music');
            
            if (this.miniContainer) {
                if (isMusicPage) {
                    this.miniContainer.classList.add('opacity-0', 'hidden');
                    this.miniContainer.classList.remove('opacity-100');
                    this.closeMiniPlayer();
                } else {
                    this.miniContainer.classList.remove('opacity-0', 'hidden');
                    this.miniContainer.classList.add('opacity-100');
                }
            }
        }

        bindGlobalAudioEvents() {
             this.audio = document.getElementById('global-audio-player');
             if(this.audio && !this.audio.dataset.hasGlobalEvents) {
                this.audio.addEventListener('timeupdate', () => this.updateProgress());
                this.audio.addEventListener('ended', () => this.nextSong(true));
                this.audio.addEventListener('play', () => { this.isPlaying = true; this.updateUI(); });
                this.audio.addEventListener('pause', () => { this.isPlaying = false; this.updateUI(); });
                this.audio.addEventListener('error', (e) => console.error("Audio error", e));
                this.audio.dataset.hasGlobalEvents = "true";
             }
             
            if ('mediaSession' in navigator) {
                navigator.mediaSession.setActionHandler('play', () => this.togglePlay());
                navigator.mediaSession.setActionHandler('pause', () => this.togglePlay());
                navigator.mediaSession.setActionHandler('previoustrack', () => this.prevSong());
                navigator.mediaSession.setActionHandler('nexttrack', () => this.nextSong());
            }
        }

        bindMiniPlayerEvents() {
            // Always query fresh elements
            this.miniContainer = document.getElementById('mini-player-container');
            this.miniCard = document.getElementById('mini-player-card');
            this.miniFab = document.getElementById('mini-fab');
            this.miniPlayBtn = document.getElementById('mini-play');
            this.miniPrevBtn = document.getElementById('mini-prev');
            this.miniNextBtn = document.getElementById('mini-next');
            
            this.miniCover = document.getElementById('mini-cover');
            this.miniFabCover = document.getElementById('mini-fab-cover');
            this.miniTitle = document.getElementById('mini-title');
            this.miniArtist = document.getElementById('mini-artist');
            this.miniIconPlay = document.getElementById('mini-icon-play');
            this.miniIconPause = document.getElementById('mini-icon-pause');
            this.miniFabSpin = document.getElementById('mini-fab-spin');
            this.miniFabIconPlay = document.getElementById('mini-fab-icon-play');
            this.miniFabIconPause = document.getElementById('mini-fab-icon-pause');
            this.visualizerBars = document.querySelectorAll('#mini-fab-visualizer div');

            // Bind events only if not already bound on THIS specific element instance
            if(this.miniFab && !this.miniFab.dataset.bound) {
                this.miniFab.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.togglePlay();
                });
                this.miniFab.addEventListener('mouseenter', () => this.openMiniPlayer());
                this.miniFab.addEventListener('mouseleave', () => this.scheduleCloseMiniPlayer());
                this.miniFab.dataset.bound = "true";
            }
            
            if(this.miniCard && !this.miniCard.dataset.bound) {
                this.miniCard.addEventListener('mouseenter', () => this.openMiniPlayer());
                this.miniCard.addEventListener('mouseleave', () => this.scheduleCloseMiniPlayer());
                this.miniCard.dataset.bound = "true";
            }
            
            // Remove old document logic for clicking outside since we are using hover now
            /* if (!this.hasBoundDocumentClick) { ... } */

            if(this.miniPlayBtn && !this.miniPlayBtn.dataset.bound) {
                this.miniPlayBtn.addEventListener('click', () => this.togglePlay());
                this.miniPlayBtn.dataset.bound = "true";
            }
            if(this.miniPrevBtn && !this.miniPrevBtn.dataset.bound) {
                this.miniPrevBtn.addEventListener('click', () => this.prevSong());
                this.miniPrevBtn.dataset.bound = "true";
            }
            if(this.miniNextBtn && !this.miniNextBtn.dataset.bound) {
                this.miniNextBtn.addEventListener('click', () => this.nextSong(false));
                this.miniNextBtn.dataset.bound = "true";
            }
        }

        bindUIEvents() {
            if (this.playBtn && !this.playBtn.dataset.bound) {
                this.playBtn.addEventListener('click', () => this.togglePlay());
                this.playBtn.dataset.bound = "true";
            }
            if (this.prevBtn && !this.prevBtn.dataset.bound) {
                this.prevBtn.addEventListener('click', () => this.prevSong());
                this.prevBtn.dataset.bound = "true";
            }
            if (this.nextBtn && !this.nextBtn.dataset.bound) {
                this.nextBtn.addEventListener('click', () => this.nextSong(false));
                this.nextBtn.dataset.bound = "true";
            }
            if (this.shuffleBtn && !this.shuffleBtn.dataset.bound) {
                this.shuffleBtn.addEventListener('click', () => this.toggleShuffle());
                this.shuffleBtn.dataset.bound = "true";
            }
            if (this.repeatBtn && !this.repeatBtn.dataset.bound) {
                this.repeatBtn.addEventListener('click', () => this.toggleRepeat());
                this.repeatBtn.dataset.bound = "true";
            }
            
            if (this.btnPlaylist && !this.btnPlaylist.dataset.bound) {
                this.btnPlaylist.addEventListener('click', () => this.switchView('playlist'));
                this.btnPlaylist.dataset.bound = "true";
            }
            if (this.btnLyrics && !this.btnLyrics.dataset.bound) {
                this.btnLyrics.addEventListener('click', () => this.switchView('lyrics'));
                this.btnLyrics.dataset.bound = "true";
            }
            
            // Progress Bar Dragging
            if(this.progressContainer && !this.progressContainer.dataset.bound) {
                const startProgressDrag = (e) => {
                    this.isDraggingProgress = true;
                    this.updateProgressFromEvent(e);

                    const onMouseMove = (moveEvent) => {
                         if (this.isDraggingProgress) {
                             moveEvent.preventDefault(); // Prevent text selection
                             this.updateProgressFromEvent(moveEvent);
                         }
                    };
                    
                    const onMouseUp = () => {
                        this.isDraggingProgress = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };
                this.progressContainer.addEventListener('mousedown', startProgressDrag);
                this.progressContainer.dataset.bound = "true";
            }
            
            // Volume Bar Dragging
             if(this.volumeControl && !this.volumeControl.dataset.bound) {
                const startVolumeDrag = (e) => {
                    this.isDraggingVolume = true;
                    this.updateVolumeFromEvent(e);
                    
                    const onMouseMove = (moveEvent) => {
                        if (this.isDraggingVolume) {
                             moveEvent.preventDefault();
                             this.updateVolumeFromEvent(moveEvent);
                        }
                    };
                    
                    const onMouseUp = () => {
                        this.isDraggingVolume = false;
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };
                this.volumeControl.addEventListener('mousedown', startVolumeDrag);
                this.volumeControl.dataset.bound = "true";
             }
        }
        
        updateProgressFromEvent(e) {
             if(!this.progressContainer || !this.audio || !this.audio.duration) return;
             const rect = this.progressContainer.getBoundingClientRect();
             const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
             this.audio.currentTime = pos * this.audio.duration;
             if(this.progressBar) this.progressBar.style.width = `${pos * 100}%`;
             if(this.currentTimeEl) this.currentTimeEl.textContent = this.formatTime(this.audio.currentTime);
        }

        updateVolumeFromEvent(e) {
            if(!this.volumeControl || !this.audio) return;
            const rect = this.volumeControl.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            this.audio.volume = pos;
            if(this.volumeBar) this.volumeBar.style.width = `${pos * 100}%`;
        }
        
        bindPlaylistEvents() {
            const playlistItems = document.querySelectorAll('.playlist-item');
            playlistItems.forEach(item => {
                item.addEventListener('click', () => {
                   const index = parseInt(item.dataset.index);
                   if(!isNaN(index)) {
                       this.loadSong(index, true);
                   }
                });
            });
        }

        async updatePlaylistDurations() {
             const items = document.querySelectorAll('.playlist-item .playlist-duration');
             this.playlist.forEach((song, index) => {
                if (items[index]) {
                    if (song.duration) {
                        items[index].textContent = song.duration;
                    } else if (song.url) {
                         // Optional: client side fetch
                    }
                }
             });
        }

        generateShuffleOrder() {
            this.shuffleOrder = Array.from({length: this.playlist.length}, (_, i) => i);
            // Fisher-Yates shuffle
            for (let i = this.shuffleOrder.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [this.shuffleOrder[i], this.shuffleOrder[j]] = [this.shuffleOrder[j], this.shuffleOrder[i]];
            }
            
            // 将当前播放的歌曲放到洗牌数组的第一个，确保洗牌后下一首不会马上重复当前这首
            const currentIdxInShuffle = this.shuffleOrder.indexOf(this.currentIndex);
            if (currentIdxInShuffle !== -1) {
                [this.shuffleOrder[0], this.shuffleOrder[currentIdxInShuffle]] = [this.shuffleOrder[currentIdxInShuffle], this.shuffleOrder[0]];
            }
            this.shuffleIndex = 0;
        }

        loadSong(index, autoPlay = true) {
            if(index < 0 || index >= this.playlist.length) return;
            
            this.currentIndex = index;

            // Save to localStorage
            try {
                localStorage.setItem('mahiro_music_current_index', this.currentIndex.toString());
            } catch(e) {}

            // 如果处于随机播放模式，同步洗牌进度
            if (this.isShuffle && this.shuffleOrder && this.shuffleOrder.length === this.playlist.length) {
                const idx = this.shuffleOrder.indexOf(index);
                if (idx !== -1) {
                    this.shuffleIndex = idx;
                }
            }

            const song = this.playlist[index];
            
            if (this.audio.src !== song.url && this.audio.src !== new URL(song.url, document.baseURI).href) {
                this.audio.src = song.url;
                this.lrcUrl = song.lrc || (song.url ? song.url.replace(/\.[^/.]+$/, ".lrc") : "");
                this.lyrics = []; // Clear lyrics
                this.hasLyrics = !!song.lrc; // 标记是否有歌词
            }

            if(autoPlay) {
                this.audio.play().catch(e => console.error(e));
            } else {
                 if (this.isPlaying) this.audio.play(); 
            }
            
            this.updateUI();
            this.loadLyrics();
            
             if('mediaSession' in navigator) {
                navigator.mediaSession.metadata = new MediaMetadata({
                    title: song.title || 'Unknown Title',
                    artist: song.artist || 'Unknown Artist',
                    artwork: [{ src: song.cover || '/favicon.ico', sizes: '512x512', type: 'image/png' }]
                });
            }
        }
        
        togglePlay() {
            if (this.audio.paused) {
                this.audio.play();
            } else {
                this.audio.pause();
            }
        }
        
        prevSong() {
            let newIndex;
            if (this.isShuffle && this.shuffleOrder && this.shuffleOrder.length === this.playlist.length) {
                this.shuffleIndex--;
                if (this.shuffleIndex < 0) {
                    this.shuffleIndex = this.shuffleOrder.length - 1;
                }
                newIndex = this.shuffleOrder[this.shuffleIndex];
            } else {
                newIndex = this.currentIndex - 1;
                if(newIndex < 0) {
                     newIndex = this.playlist.length - 1; 
                }
            }
            this.loadSong(newIndex, true);
        }
        
        nextSong(isAuto = false) {
             let newIndex;
            if (this.repeatMode === 'one' && isAuto) {
                 newIndex = this.currentIndex;
            } else if (this.isShuffle) {
                if (!this.shuffleOrder || this.shuffleOrder.length !== this.playlist.length) {
                    this.generateShuffleOrder();
                }
                this.shuffleIndex++;
                if (this.shuffleIndex >= this.shuffleOrder.length) {
                    this.generateShuffleOrder(); // 一轮播完，重新洗牌
                    this.shuffleIndex = 1; // 0是当前这首，所以播第1首
                    if (this.shuffleOrder.length > 1) {
                        newIndex = this.shuffleOrder[this.shuffleIndex];
                    } else {
                        newIndex = this.shuffleOrder[0];
                    }
                } else {
                    newIndex = this.shuffleOrder[this.shuffleIndex];
                }
            } else {
                newIndex = this.currentIndex + 1;
                if(newIndex >= this.playlist.length) {
                    if (this.repeatMode === 'off' && isAuto) {
                         this.isPlaying = false;
                         this.updateUI();
                         return; 
                    }
                    newIndex = 0;
                }
            }
            this.loadSong(newIndex, true);
        }
        
        toggleShuffle() {
            this.isShuffle = !this.isShuffle;
            
            if (this.isShuffle) {
                this.generateShuffleOrder();
                this.repeatMode = 'off';
            } else {
                this.repeatMode = 'all';
                this.shuffleOrder = [];
            }
            this.updateUI();
        }

        toggleRepeat() {
             if (this.isShuffle) {
                 this.isShuffle = false;
                 this.repeatMode = 'all'; 
             } else {
                 if (this.repeatMode === 'all') {
                     this.repeatMode = 'one';
                 } else if (this.repeatMode === 'one') {
                     this.repeatMode = 'off';
                 } else {
                     this.repeatMode = 'all';
                 }
             }
             this.updateUI();
        }

        toggleMiniPlayer() {
             // Deprecated in favor of open/close hover
            if (!this.isMiniOpen) {
                this.openMiniPlayer();
            } else {
                this.closeMiniPlayer();
            }
        }

        closeMiniPlayer() {
            this.isMiniOpen = false;
            // 新版滑回动画 (横向缩回)
            this.miniCard?.classList.add('-translate-x-full', 'opacity-0', 'pointer-events-none');
            this.miniCard?.classList.remove('translate-x-0', 'opacity-100', 'pointer-events-auto');
        }

        openMiniPlayer() {
            this.cancelCloseMiniPlayer();
            this.isMiniOpen = true;
            // 新版滑出动画 (横向展开)
            this.miniCard?.classList.remove('-translate-x-full', 'opacity-0', 'pointer-events-none');
            this.miniCard?.classList.add('translate-x-0', 'opacity-100', 'pointer-events-auto');
        }

        scheduleCloseMiniPlayer() {
            this.cancelCloseMiniPlayer();
            this.closeTimer = setTimeout(() => {
                this.closeMiniPlayer();
            }, 300);
        }

        cancelCloseMiniPlayer() {
            if (this.closeTimer) {
                clearTimeout(this.closeTimer);
                this.closeTimer = null;
            }
        }

        switchView(view) {
            if (view === 'playlist') {
                this.lyricsContainer?.classList.add('hidden');
                this.playlistContainer?.classList.remove('hidden');
                this.btnPlaylist?.classList.remove('text-neu-text-muted');
                this.btnPlaylist?.classList.add('bg-neu-btn-bg', 'text-neu-btn-text', 'shadow-sm');
                this.btnLyrics?.classList.add('text-neu-text-muted');
                this.btnLyrics?.classList.remove('bg-neu-btn-bg', 'text-neu-btn-text', 'shadow-sm');
            } else {
                this.lyricsContainer?.classList.remove('hidden');
                this.playlistContainer?.classList.add('hidden');
                this.btnLyrics?.classList.remove('text-neu-text-muted');
                this.btnLyrics?.classList.add('bg-neu-btn-bg', 'text-neu-btn-text', 'shadow-sm');
                this.btnPlaylist?.classList.add('text-neu-text-muted');
                this.btnPlaylist?.classList.remove('bg-neu-btn-bg', 'text-neu-btn-text', 'shadow-sm');
            }
        }
        
        updateUI() {
             const song = this.playlist[this.currentIndex];
             if (!song) return;
             const coverSrc = song.cover || "";
             
             // --- Update Mini Player ---
             if (this.miniTitle) this.miniTitle.textContent = song.title || "Unknown Title";
             if (this.miniArtist) this.miniArtist.textContent = song.artist || "Unknown Artist";
             if (this.miniCover) this.miniCover.src = coverSrc;
             if (this.miniFabCover) this.miniFabCover.src = coverSrc;

             if (this.isPlaying) {
                 this.miniIconPlay?.classList.add('hidden');
                 this.miniIconPause?.classList.remove('hidden');
                 
                 this.miniFabIconPlay?.classList.add('hidden');
                 this.miniFabIconPause?.classList.remove('hidden');
                 
                 if (this.miniFabSpin) this.miniFabSpin.style.animationPlayState = 'running';
                  // Visualizer animation
                  if(this.visualizerBars) {
                      this.visualizerBars.forEach(bar => {
                          bar.classList.add('animate-pulse');
                          bar.style.height = Math.random() * 12 + 4 + 'px';
                      });
                  }
             } else {
                 this.miniIconPlay?.classList.remove('hidden');
                 this.miniIconPause?.classList.add('hidden');
                 
                 this.miniFabIconPlay?.classList.remove('hidden');
                 this.miniFabIconPause?.classList.add('hidden');

                 if (this.miniFabSpin) this.miniFabSpin.style.animationPlayState = 'paused';
                 if(this.visualizerBars) {
                      this.visualizerBars.forEach(bar => bar.classList.remove('animate-pulse'));
                  }
             }
             
             // --- Update Main Player (if exists) ---
            if (this.container) {
                // Text
                if(this.playerTitle) this.playerTitle.textContent = song.title || "Unknown Title";
                if(this.playerArtist) this.playerArtist.textContent = song.artist || "Unknown Artist";
                
                // Covers
                if(this.playerCover) this.playerCover.src = coverSrc;
                if(this.bgCover) this.bgCover.src = coverSrc;
                
                // Shuffle/Repeat State
                this.updateShuffleBtn();
                this.updateRepeatBtn();

                // Play/Pause State
                if (this.isPlaying) {
                    this.iconPlay?.classList.add('hidden');
                    this.iconPause?.classList.remove('hidden');
                    if (this.recordOuter) this.recordOuter.style.animationPlayState = 'running';
                    if (this.recordInner) this.recordInner.style.animationPlayState = 'running';
                    if (this.needle) this.needle.style.transform = 'rotate(30deg)';
                    if (this.statusDot) {
                        this.statusDot.classList.remove('bg-red-400');
                        this.statusDot.classList.add('bg-green-400');
                    }
                    if (this.statusText) this.statusText.textContent = '播放中';
                } else {
                    this.iconPlay?.classList.remove('hidden');
                    this.iconPause?.classList.add('hidden');
                    if (this.recordOuter) this.recordOuter.style.animationPlayState = 'paused';
                    if (this.recordInner) this.recordInner.style.animationPlayState = 'paused';
                    if (this.needle) this.needle.style.transform = 'rotate(0deg)';
                    if (this.statusDot) {
                        this.statusDot.classList.remove('bg-green-400');
                        this.statusDot.classList.add('bg-red-400');
                    }
                    if (this.statusText) this.statusText.textContent = '暂停';
                }
                
                // Update Active Playlist Item
                const items = document.querySelectorAll('.playlist-item');
                items.forEach((item, idx) => {
                    const iconDiv = item.querySelector('.absolute.inset-0.bg-black\\/10'); 
                    const title = item.querySelector('h3');
                    
                    if(idx === this.currentIndex) {
                        item.classList.add('active', 'border-neu-accent', 'bg-black/5', 'dark:bg-white/5');
                        item.classList.remove('border-transparent');
                        if(iconDiv) iconDiv.classList.remove('opacity-0');
                        if(title) title.classList.add('text-neu-accent');
                    } else {
                        item.classList.remove('active', 'border-neu-accent', 'bg-black/5', 'dark:bg-white/5');
                        item.classList.add('border-transparent');
                        if(iconDiv) iconDiv.classList.add('opacity-0');
                        if(title) title.classList.remove('text-neu-accent');
                    }
                });
            }
        }
        
         updateShuffleBtn() {
            if (this.shuffleBtn) {
                if (this.isShuffle) {
                    this.shuffleBtn.style.color = 'oklch(var(--p))';
                    this.shuffleBtn.classList.remove('text-neu-text-muted');
                } else {
                    this.shuffleBtn.style.color = '';
                    this.shuffleBtn.classList.add('text-neu-text-muted');
                }
            }
        }
        
        updateRepeatBtn() {
             if (this.repeatBtn) {
                // Highlight if 'all' or 'one'
                if (this.repeatMode === 'all' || this.repeatMode === 'one') {
                     this.repeatBtn.style.color = 'oklch(var(--p))';
                     this.repeatBtn.classList.remove('text-neu-text-muted');
                } else {
                     this.repeatBtn.style.color = '';
                     this.repeatBtn.classList.add('text-neu-text-muted');
                }
                
                // Optional: We could try to show visual distinction for 'one'
                // But without icon changing support, highlighting is the primary request.
            }
        }

        updateProgress() {
            if(!this.audio) return;
            // Stop updating UI if user is dragging progress bar
            if(this.isDraggingProgress) return;
            
            const { currentTime, duration } = this.audio;
            // Only update if UI exists
            if(this.currentTimeEl) this.currentTimeEl.textContent = this.formatTime(currentTime);
            if(this.totalTimeEl && duration) this.totalTimeEl.textContent = this.formatTime(duration);
            
            if(duration) {
                const percent = (currentTime / duration) * 100;
                if(this.progressBar) this.progressBar.style.width = `${percent}%`;

                // Update Mini Player SVG Progress Ring
                const ring = document.getElementById('mini-progress-ring');
                if (ring) {
                    const circumference = 2 * Math.PI * 48; // r=48
                    const offset = circumference - (percent / 100) * circumference;
                    ring.style.strokeDashoffset = offset;
                }
            }

            this.syncLyrics(currentTime);
            
             // Visualizer animation
             if(this.isPlaying && this.visualizerBars) {
                  this.visualizerBars.forEach(bar => {
                      bar.style.height = (Math.random() * 8 + 4) + 'px';
                  });
              }
        }
        
        formatTime(seconds) {
            if (isNaN(seconds)) return "0:00";
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60);
            return `${min}:${sec.toString().padStart(2, '0')}`;
        }
        
        async loadLyrics() {
             try {
                const currentSong = this.playlist[this.currentIndex];
                
                if(!this.lrcUrl) {
                    // 如果没有生成lrcUrl，则认为是纯音乐
                    if(this.lyricsContainer) {
                        this.lyricsContainer.innerHTML = '<p class="text-neu-text-muted text-sm mt-20">纯音乐，请您欣赏</p>';
                    }
                    return;
                }
                
                // 尝试加载歌词
                const response = await fetch(this.lrcUrl);
                if (response.ok) {
                    const text = await response.text();
                    this.lyrics = this.parseLyrics(text);
                    // 如果解析后歌词为空，且没有显式设置lrc属性，则认为是纯音乐
                    if (this.lyrics.length === 0 && !currentSong.lrc) {
                        if(this.lyricsContainer) {
                            this.lyricsContainer.innerHTML = '<p class="text-neu-text-muted text-sm mt-20">纯音乐，请您欣赏</p>';
                        }
                        return;
                    }
                    this.renderLyrics();
                } else {
                    // 如果加载失败，且没有显式设置lrc属性，则认为是纯音乐
                    if (!currentSong.lrc) {
                        if(this.lyricsContainer) {
                            this.lyricsContainer.innerHTML = '<p class="text-neu-text-muted text-sm mt-20">纯音乐，请您欣赏</p>';
                        }
                    } else {
                        // 如果有显式设置lrc属性但加载失败，显示加载失败提示
                        if(this.lyricsContainer) this.lyricsContainer.innerHTML = '<p class="text-neu-text-muted text-sm mt-20">Lyrics fetch failed</p>';
                    }
                }
            } catch (e) {
                // console.error("Lyrics load failed", e);
                const currentSong = this.playlist[this.currentIndex];
                // 如果加载出错，且没有显式设置lrc属性，则认为是纯音乐
                if (!currentSong.lrc) {
                    if(this.lyricsContainer) {
                        this.lyricsContainer.innerHTML = '<p class="text-neu-text-muted text-sm mt-20">纯音乐，请您欣赏</p>';
                    }
                } else {
                    // 如果有显式设置lrc属性但加载出错，显示没有歌词提示
                    if(this.lyricsContainer) this.lyricsContainer.innerHTML = '<p class="text-neu-text-muted text-sm mt-20">No lyrics available</p>';
                }
            }
        }
        
        parseLyrics(lrcText) {
            const lines = lrcText.split('\n');
            const result = [];
            const timeReg = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
            
            for (const line of lines) {
                const cleanLine = line.trim();
                const match = timeReg.exec(cleanLine);
                if (match) {
                    const min = parseInt(match[1]);
                    const sec = parseInt(match[2]);
                    const ms = parseInt(match[3].padEnd(3, '0')); // Handle 2 or 3 digits
                    
                    const time = min * 60 + sec + ms / 1000;
                    const text = cleanLine.replace(timeReg, '').trim();
                    
                    if (text) {
                        result.push({ time, text });
                    }
                }
            }
            return result;
        }

        renderLyrics() {
            if (!this.lyricsContainer) return;
            
            const html = this.lyrics.map((line, index) => {
                return `<p class="lyric-line transition-all duration-500 py-1 text-neu-text-muted hover:text-neu-text cursor-pointer text-sm font-medium tracking-wide" data-time="${line.time}" data-index="${index}">${line.text}</p>`;
            }).join('');
            
            this.lyricsContainer.innerHTML = `<div class="py-[50%] flex flex-col items-center w-full space-y-4">${html}</div>`; 
            
            const lines = this.lyricsContainer.querySelectorAll('.lyric-line');
            lines.forEach(line => {
                line.addEventListener('click', () => {
                   const time = parseFloat(line.getAttribute('data-time'));
                   if(this.audio) {
                       this.audio.currentTime = time;
                       if (this.audio.paused) this.togglePlay();
                   }
                });
            });
        }
        
        syncLyrics(currentTime) {
             if (!this.lyrics.length || !this.lyricsContainer) return;
            
            // Find current line
            let activeIndex = -1;
            for (let i = 0; i < this.lyrics.length; i++) {
                if (currentTime >= this.lyrics[i].time) {
                    activeIndex = i;
                } else {
                    break;
                }
            }
            
            if (activeIndex !== -1 && activeIndex !== this.lastActiveIndex) {
                 this.lastActiveIndex = activeIndex;

                const lines = this.lyricsContainer.querySelectorAll('.lyric-line');
                
                lines.forEach((line, idx) => {
                    if (idx !== activeIndex) {
                         line.className = 'lyric-line transition-all duration-500 py-1 text-neu-text-muted hover:text-neu-text cursor-pointer text-sm font-medium tracking-wide';
                    }
                });
                
                const activeLine = lines[activeIndex];
                if (activeLine) {
                    activeLine.className = 'lyric-line transition-all duration-500 py-1 cursor-pointer text-base font-bold tracking-wider lyric-active';
                    
                    // Manual scroll calculation to prevent whole page scrolling
                    const containerHeight = this.lyricsContainer.clientHeight;
                    const lineTop = activeLine.offsetTop;
                    const lineHeight = activeLine.clientHeight;
                    
                    // Calculate center position
                    const scrollTarget = lineTop - (containerHeight / 2) + (lineHeight / 2);

                    this.lyricsContainer.scrollTo({
                        top: scrollTarget,
                        behavior: 'smooth'
                    });
                }
            }
        }
    }
    
    // Initialize Singleton
    if (!window.globalMusicPlayer) {
        window.globalMusicPlayer = new GlobalMusicPlayer();
    } else {
        // HMR Support: When file changes, we need to update the methods of the existing instance
        // or replace the instance while preserving state.
        const oldInstance = window.globalMusicPlayer;
        const newInstance = new GlobalMusicPlayer();
        
        // Preserve State
        newInstance.playlist = oldInstance.playlist;
        newInstance.currentIndex = oldInstance.currentIndex;
        newInstance.isPlaying = oldInstance.isPlaying;
        newInstance.isShuffle = oldInstance.isShuffle;
        newInstance.repeatMode = oldInstance.repeatMode;
        newInstance.lyrics = oldInstance.lyrics;
        newInstance.lrcUrl = oldInstance.lrcUrl;
        newInstance.audio = oldInstance.audio;
        newInstance.isMiniOpen = oldInstance.isMiniOpen;
        
        // cleanup old events/timers if necessary
        if(oldInstance.closeTimer) clearTimeout(oldInstance.closeTimer);
        
        // Replace
        window.globalMusicPlayer = newInstance;
        window.globalMusicPlayer.handlePageLoad();
    }
</script>
