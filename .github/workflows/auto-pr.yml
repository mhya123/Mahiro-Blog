name: Admin Friend Link Audit

on:
  pull_request_target:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: å‹é“¾è‡ªåŠ¨åŒ–å®¡æ ¸ä¸åˆå¹¶
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = context.payload.pull_request.number;
            const head_sha = context.payload.pull_request.head.sha;

            // ================= å¸¸é‡å®šä¹‰åŒº =================
            const MY_DOMAINS = ['mahiro.work']; // å¡«ä½ éœ€è¦åŒ¹é…çš„æ ¸å¿ƒä¸»åŸŸåæˆ–å¤šä¸ªåŸŸå

            // å…¨ä¸­æ–‡ä¸“ä¸šæ ‡ç­¾
            const LABELS = {
              BASE: 'å‹é“¾ç”³è¯·',
              RUNNING: 'å®¡æ ¸ä¸­',
              PASSED: 'å®¡æ ¸é€šè¿‡',
              NEED_FIX: 'å¾…ä¿®æ”¹',
              SITE_OK: 'ç«™ç‚¹æ­£å¸¸',
              SITE_ERR: 'ç«™ç‚¹å¼‚å¸¸',
              AVATAR_OK: 'å¤´åƒæ­£å¸¸',
              AVATAR_ERR: 'å¤´åƒå¼‚å¸¸',
              LINK_OK: 'åé“¾æœ‰æ•ˆ',
              LINK_ERR: 'åé“¾ç¼ºå¤±'
            };

            const MSG = {
              PR_MULTI_FILES: 'PR å¿…é¡»ä»…åŒ…å« 1 ä¸ªæ–‡ä»¶çš„å˜æ›´ã€‚',
              PR_PATH_ERR: 'ä¿®æ”¹è·¯å¾„å¿…é¡»ä¸¥æ ¼é™åˆ¶åœ¨ `src/data/friends/` ç›®å½•ä¸‹ï¼Œä¸”æ–‡ä»¶æ‰©å±•åå¿…é¡»æ˜¯ `.json`ã€‚',
              PR_FILENAME_ERR: 'æ–‡ä»¶åæ ¡éªŒå¤±è´¥ï¼šè¯·ä¸è¦ç›´æ¥ä½¿ç”¨æ¨¡æ¿é»˜è®¤çš„ `ä½ çš„åå­—.json`ï¼Œè¯·å°†å…¶é‡å‘½åä¸ºæ‚¨è‡ªå·±çš„ç«™ç‚¹åç§°æˆ– IDã€‚',
              PR_ACTION_ERR: 'åªå…è®¸æ–°å¢ (added) æˆ–ä¿®æ”¹ (modified) æ–‡ä»¶ã€‚',
              JSON_PARSE_ERR: 'JSON è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æ˜¯å¦ç¬¦åˆè§„èŒƒã€‚',
              JSON_KEY_ERR: 'JSON ç¼ºå°‘å¿…å¡«å­—æ®µï¼Œå¿…é¡»åŒ…å«ï¼šname, avatar, description, url, badgeã€‚',
              BADGE_ERR: 'å­—æ®µæ ¡éªŒæœªé€šè¿‡ï¼šbadge çš„å€¼å¿…é¡»ä¸¥æ ¼å¡«å†™ã€‚ä»…å…è®¸å¡«å†™ "å¥½å‹", "å‹æƒ…" æˆ– "å‹æƒ…é“¾æ¥"ã€‚',
              SSRF_BLOCK: 'å®‰å…¨æ‹¦æˆªï¼šç›®æ ‡ URL ç–‘ä¼¼æŒ‡å‘å†…ç½‘æˆ–ä¿ç•™ IPã€‚',
              SUCCESS: `ğŸ‰ **å®¡æ ¸é€šè¿‡ï¼**\n\næ„Ÿè°¢ç”³è¯·ï¼ç³»ç»Ÿå·²æ£€æµ‹åˆ°æœ‰æ•ˆçš„åŒå‘é“¾æ¥å¹¶ç¡®è®¤æ ¼å¼æ— è¯¯ï¼Œç°åœ¨ä¸ºæ‚¨è‡ªåŠ¨æ‰§è¡Œåˆå¹¶ (Squash Merge)ã€‚`,
              REJECT: `æ‚¨å¥½ï¼æ„Ÿè°¢å¯¹æœ¬ç«™çš„å…³æ³¨ã€‚\n\nç”±äºè‡ªåŠ¨åŒ–å®¡æ ¸æœªèƒ½æ£€æµ‹åˆ°æœ‰æ•ˆçš„åé“¾ã€ç«™ç‚¹è®¿é—®å¼‚å¸¸æˆ–æ ¼å¼æœ‰è¯¯ï¼ˆè¯¦æƒ…è¯·è§ä¸Šæ–¹å®¡æ ¸æŠ¥å‘Šï¼‰ï¼Œä¸ºäº†ä¿æŒä»“åº“ PR é˜Ÿåˆ—çš„æ•´æ´ï¼Œç³»ç»Ÿå·²æš‚æ—¶ **å…³é—­** æ­¤ PRã€‚\n\n### ğŸ’¡ æ­£ç¡®çš„ JSON æ ¼å¼å‚è€ƒï¼š\nè¯·ç¡®ä¿æ‚¨æäº¤çš„æ–‡ä»¶å†…å®¹ä¸¥æ ¼ç¬¦åˆä»¥ä¸‹æ ¼å¼ï¼Œå¹¶å°†æ–‡ä»¶åæ”¹ä¸º \`æ‚¨çš„ç½‘ç«™å.json\`ã€‚\n**ï¼ˆğŸš¨æ³¨æ„ï¼šå¦‚æœæ‚¨çš„æœ¬ç«™é“¾æ¥æ”¾åœ¨äº†ä¸“é—¨çš„äºŒçº§é¡µé¢ä¾‹å¦‚ /friendsï¼Œè¯·åŠ¡å¿…å¡«å†™ \`backlink\` å­—æ®µæŒ‡è·¯ï¼ï¼‰**\n\n\`\`\`json\n{\n  "name": "æ‚¨çš„ç½‘ç«™å",\n  "avatar": "https://æ‚¨çš„å¤´åƒURL",\n  "description": "æ‚¨çš„ç½‘ç«™æè¿°",\n  "url": "https://æ‚¨çš„ç½‘ç«™URL",\n  "backlink": "https://æ‚¨çš„å‹é“¾é¡µURL (é€‰å¡«)",\n  "badge": "å‹æƒ…"\n}\n\`\`\`\n\nè¯·æ‚¨å‚è€ƒä¸Šæ–¹çš„é”™è¯¯æŠ¥å‘Šä¸æ­£ç¡®æ ¼å¼ä¿®æ­£åï¼Œé‡æ–°å¼€å¯æˆ–æäº¤æ–°çš„ PRï¼ŒæœŸå¾…æ‚¨çš„åŠ å…¥ï¼`
            };

            // ================= è¾…åŠ©å‡½æ•° =================
            async function createComment(body) {
              const runUrl = `${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`;
              const footer = `\n\n---\n*ğŸ¤– è¯¥è¯„è®ºç”± Action è‡ªåŠ¨åŒ–å‘é€ï¼Œæ— éœ€å›å¤ã€‚ [æŸ¥çœ‹æ„å»ºæ—¥å¿—](${runUrl})*`;
              await github.rest.issues.createComment({ owner, repo, issue_number: pull_number, body: body + footer });
            }

            async function ensureLabel(name, color = 'ededed') {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({ owner, repo, name, color });
                }
              }
            }

            // æ™ºèƒ½åˆ†é…æ ‡ç­¾é¢œè‰²
            function getLabelColor(name) {
              const greenLabels = ['å®¡æ ¸é€šè¿‡', 'ç«™ç‚¹æ­£å¸¸', 'å¤´åƒæ­£å¸¸', 'åé“¾æœ‰æ•ˆ'];
              const redLabels = ['å¾…ä¿®æ”¹', 'ç«™ç‚¹å¼‚å¸¸', 'å¤´åƒå¼‚å¸¸', 'åé“¾ç¼ºå¤±'];
              if (greenLabels.includes(name)) return '0e8a16'; // ç»¿è‰²
              if (redLabels.includes(name)) return 'd93f0b';   // çº¢è‰²
              return '1d76db'; // è“è‰² (é»˜è®¤)
            }

            // ç¼“å­˜å½“å‰æ ‡ç­¾çŠ¶æ€ï¼Œé¿å…æ¯æ¬¡è°ƒç”¨éƒ½é‡æ–° GET
            let _labelCache = null;
            async function getLabelCache() {
              if (!_labelCache) {
                const current = await github.rest.issues.get({ owner, repo, issue_number: pull_number });
                _labelCache = new Set((current.data.labels || []).map(l => l.name));
              }
              return _labelCache;
            }

            async function manageLabels(addList = [], removeList = []) {
              const currentLabels = await getLabelCache();

              for (const name of addList) {
                if (!currentLabels.has(name)) {
                  await ensureLabel(name, getLabelColor(name));
                  await github.rest.issues.addLabels({ owner, repo, issue_number: pull_number, labels: [name] });
                  currentLabels.add(name);
                }
              }
              for (const name of removeList) {
                if (currentLabels.has(name)) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: pull_number, name });
                    currentLabels.delete(name);
                  } catch (e) { /* ignore */ }
                }
              }
            }

            function isSafeUrl(urlStr) {
              try {
                const u = new URL(urlStr);
                if (u.protocol !== 'http:' && u.protocol !== 'https:') return false;
                const h = u.hostname;
                if (/^(localhost|127\.|10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|::1)/i.test(h)) return false;
                return true;
              } catch { return false; }
            }

            async function fetchWithTimeout(url, timeoutMs = 10000, { headOnly = false } = {}) {
              const controller = new AbortController();
              const timer = setTimeout(() => controller.abort(), timeoutMs);
              try {
                const res = await fetch(url, {
                  method: headOnly ? 'HEAD' : 'GET',
                  headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },
                  signal: controller.signal,
                  redirect: 'follow'
                });
                const text = headOnly ? '' : await res.text();
                return { ok: res.ok, status: res.status, text };
              } catch (e) {
                return { ok: false, error: e.message };
              } finally {
                clearTimeout(timer);
              }
            }

            // ================= æ ¸å¿ƒæ‰§è¡Œé€»è¾‘ =================
            await manageLabels([LABELS.BASE, LABELS.RUNNING], []);
            const reportData = [];
            let isFailed = false;
            let applySiteName = "æœªçŸ¥ç«™ç‚¹";

            try {
              // 1. è·å– PR æ–‡ä»¶åˆ—è¡¨
              const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number });
              
              if (files.length !== 1) throw new Error(MSG.PR_MULTI_FILES);
              const file = files[0];
              
              // æ ¡éªŒè·¯å¾„å’Œæ‰©å±•å
              if (!file.filename.startsWith('src/data/friends/') || !file.filename.endsWith('.json')) {
                throw new Error(MSG.PR_PATH_ERR);
              }
              // é˜²å‘†æ ¡éªŒï¼šæ‹¦æˆªç›´æ¥ä½¿ç”¨ "ä½ çš„åå­—.json" çš„æäº¤
              if (file.filename.endsWith('/ä½ çš„åå­—.json')) {
                throw new Error(MSG.PR_FILENAME_ERR);
              }
              if (file.status !== 'added' && file.status !== 'modified') {
                throw new Error(MSG.PR_ACTION_ERR);
              }

              // 2. è¯»å–æ–‡ä»¶å†…å®¹è¿›è¡Œ JSON æ ¼å¼æ£€æŸ¥
              const prHead = context.payload.pull_request.head;
              const { data: fileData } = await github.rest.repos.getContent({
                owner: prHead.repo.owner.login,
                repo: prHead.repo.name,
                path: file.filename,
                ref: head_sha
              });
              const contentStr = Buffer.from(fileData.content, 'base64').toString('utf-8');
              
              let json;
              try { json = JSON.parse(contentStr); } catch { throw new Error(MSG.JSON_PARSE_ERR); }

              const requiredKeys = ['name', 'avatar', 'description', 'url', 'badge'];
              const missingKeys = requiredKeys.filter(k => !json[k] || typeof json[k] !== 'string');
              if (missingKeys.length > 0) throw new Error(`${MSG.JSON_KEY_ERR} ç¼ºå¤±: ${missingKeys.join(', ')}`);
              
              applySiteName = json.name.trim();

              const allowedBadges = ['å¥½å‹', 'å‹æƒ…', 'å‹æƒ…é“¾æ¥'];
              if (!allowedBadges.includes(json.badge.trim())) {
                throw new Error(MSG.BADGE_ERR);
              }
              
              reportData.push({ item: 'JSON æ ¼å¼', status: 'âœ… é€šå…³', detail: 'å­—æ®µæ ¡éªŒå®Œæ•´ä¸”è§„èŒƒ' });

              // 3. å®‰å…¨é˜²æŠ¤ SSRF (åŒ…æ‹¬æ–°åŠ çš„ backlink å­—æ®µ)
              if (!isSafeUrl(json.url) || !isSafeUrl(json.avatar) || (json.backlink && !isSafeUrl(json.backlink))) {
                throw new Error(MSG.SSRF_BLOCK);
              }

              // 4. å¹¶å‘å‘èµ·ç½‘ç»œè¯·æ±‚ï¼ˆé‡ç‚¹ï¼šbacklink é€»è¾‘åˆ¤æ–­ï¼‰
              const fetchTasks = [
                fetchWithTimeout(json.avatar, 10000, { headOnly: true }), // [0] æµ‹å¤´åƒ
                fetchWithTimeout(json.url)                                // [1] æµ‹ä¸»ç«™å­˜æ´»
              ];

              // â˜… å¦‚æœç”¨æˆ·å¡«å†™äº† backlink å­—æ®µï¼Œå°±é¢å¤–å‘èµ·ä¸€ä¸ªè¯·æ±‚å»æ‰’è¿™ä¸ªæŒ‡å®šçš„é¡µé¢
              const hasCustomBacklink = typeof json.backlink === 'string' && json.backlink.trim() !== '';
              if (hasCustomBacklink) {
                fetchTasks.push(fetchWithTimeout(json.backlink.trim()));  // [2] å»ä¸“å±å‹é“¾é¡µæ‰’åé“¾
              }

              const results = await Promise.all(fetchTasks);
              const avatarRes = results[0];
              const siteRes = results[1];
              
              // â˜… æ ¸å¿ƒé€»è¾‘ï¼šå¦‚æœæœ‰ backlink å°±ç”¨ backlink çš„é¡µé¢æºç ï¼Œæ²¡å†™å°±é»˜è®¤ç”¨ä¸»ç«™ url çš„æºç 
              const backlinkRes = hasCustomBacklink ? results[2] : siteRes;
              const checkTargetUrl = hasCustomBacklink ? json.backlink.trim() : json.url;

              // éªŒè¯å¤´åƒ
              if (avatarRes.ok) {
                reportData.push({ item: 'å¤´åƒè¿é€šæ€§', status: 'âœ… æ­£å¸¸', detail: `çŠ¶æ€ç : ${avatarRes.status}` });
                await manageLabels([LABELS.AVATAR_OK]);
              } else {
                isFailed = true;
                reportData.push({ item: 'å¤´åƒè¿é€šæ€§', status: 'âŒ å¤±è´¥', detail: avatarRes.error || `çŠ¶æ€ç : ${avatarRes.status}` });
                await manageLabels([LABELS.AVATAR_ERR]);
              }

              // éªŒè¯ç«™ç‚¹ (æ°¸è¿œåªæµ‹ json.url æ˜¯å¦å­˜æ´»ï¼Œä¿è¯å¯¼æµåœ°å€æ²¡æŒ‚)
              if (siteRes.ok) {
                reportData.push({ item: 'ç«™ç‚¹è¿é€šæ€§', status: 'âœ… æ­£å¸¸', detail: `çŠ¶æ€ç : ${siteRes.status}` });
                await manageLabels([LABELS.SITE_OK]);
              } else {
                isFailed = true;
                reportData.push({ item: 'ç«™ç‚¹è¿é€šæ€§', status: 'âŒ å¤±è´¥', detail: siteRes.error || `çŠ¶æ€ç : ${siteRes.status}` });
                await manageLabels([LABELS.SITE_ERR]);
              }

              // éªŒè¯åé“¾ (å» checkTargetUrl é‡Œé¢æ‰’)
              if (backlinkRes.ok) {
                const html = backlinkRes.text;
                let hasBacklink = false;
                let isNofollow = false;

                const domainPattern = MY_DOMAINS.map(d => d.replace(/\./g, '\\.')).join('|');
                const linkRegex = new RegExp(`<a[^>]*href\\s*=\\s*["'][^"']*(${domainPattern})[^"']*["'][^>]*>`, 'gi');
                
                let match;
                while ((match = linkRegex.exec(html)) !== null) {
                  hasBacklink = true;
                  if (match[0].toLowerCase().includes('rel="nofollow"')) {
                    isNofollow = true;
                  }
                }

                if (hasBacklink) {
                  const nofollowTag = isNofollow ? ' *(æ³¨: æ£€æµ‹åˆ° nofollow å±æ€§)*' : '';
                  // åœ¨æŠ¥å‘Šé‡Œæ˜ç¡®æ‰“å°å‡ºå®ƒåˆ°åº•æ˜¯åœ¨å“ªä¸ªé¡µé¢(ä¸»ç«™è¿˜æ˜¯ä¸“å±é¡µ)æ‰¾åˆ°çš„åé“¾
                  reportData.push({ item: 'åé“¾æ£€æµ‹', status: 'âœ… å·²æ‰¾åˆ°', detail: `åœ¨ [ç›®æ ‡é¡µé¢](${checkTargetUrl}) ä¸­å‘ç°æœ¬ç«™é“¾æ¥${nofollowTag}` });
                  await manageLabels([LABELS.LINK_OK]);
                } else {
                  isFailed = true;
                  reportData.push({ item: 'åé“¾æ£€æµ‹', status: 'âŒ ç¼ºå¤±', detail: `æœªåœ¨ [ç›®æ ‡é¡µé¢](${checkTargetUrl}) æ‰¾åˆ°æŒ‡å‘æœ¬ç«™çš„è¶…é“¾æ¥` });
                  await manageLabels([LABELS.LINK_ERR]);
                }
              } else {
                isFailed = true;
                reportData.push({ item: 'åé“¾æ£€æµ‹', status: 'âŒ å¤±è´¥', detail: `æ— æ³•è®¿é—®æ‰’å–åé“¾çš„ç›®æ ‡é¡µé¢ï¼ŒçŠ¶æ€ç : ${backlinkRes.status}` });
                await manageLabels([LABELS.LINK_ERR]);
              }

            } catch (err) {
              isFailed = true;
              reportData.push({ item: 'å‰ç½®æ ¡éªŒæ‹¦æˆª', status: 'âŒ æœªé€šè¿‡', detail: err.message });
            }

            // ================= æŠ¥å‘Šç”Ÿæˆä¸æœ€ç»ˆåŠ¨ä½œ =================
            let markdownTable = `### ğŸ” è‡ªåŠ¨åŒ–å®¡æ ¸æŠ¥å‘Š\n\n| æ£€æŸ¥é¡¹ç›® | çŠ¶æ€ | è¯¦ç»†è¯´æ˜ |\n| :--- | :--- | :--- |\n`;
            reportData.forEach(r => { markdownTable += `| **${r.item}** | ${r.status} | ${r.detail} |\n`; });

            if (isFailed) {
              await manageLabels([LABELS.NEED_FIX], [LABELS.RUNNING]);
              await createComment(`${markdownTable}\n\n---\n\n${MSG.REJECT}`);
              // å¼ºåˆ¶å…³é—­ PR
              await github.rest.pulls.update({ owner, repo, pull_number, state: 'closed' });
              core.setFailed('è‡ªåŠ¨åŒ–å®¡æ ¸æœªé€šè¿‡ï¼Œå·²å…³é—­ PRã€‚');
            } else {
              await manageLabels([LABELS.PASSED], [LABELS.RUNNING]);
              await createComment(`${markdownTable}\n\n---\n\n${MSG.SUCCESS}`);
              
              // æ ¼å¼åŒ–å½“å‰æ—¶é—´ (ä¸œå…«åŒº)
              const nowTime = new Date().toLocaleString('zh-CN', { timeZone: 'Asia/Shanghai' });
              const commitTitle = `âœ¨ æ–°å¢å‹é“¾: ${applySiteName}`;
              const commitMsg = `${applySiteName} åœ¨ ${nowTime} æäº¤äº†å‹é“¾ç”³è¯·ï¼Œå¹¶ç”± Action è‡ªåŠ¨å®¡æ ¸é€šè¿‡å¹¶åˆå¹¶ã€‚`;

              // æ‰§è¡Œè‡ªåŠ¨ Squash Mergeï¼ˆå¸¦è‡ªå®šä¹‰æäº¤ä¿¡æ¯ï¼‰
              try {
                await github.rest.pulls.merge({ 
                  owner, 
                  repo, 
                  pull_number, 
                  merge_method: 'squash',
                  commit_title: commitTitle,
                  commit_message: commitMsg
                });
              } catch (mergeErr) {
                await createComment(`âš ï¸ è‡ªåŠ¨åˆå¹¶å¤±è´¥: ${mergeErr.message}\n\nè¯·ä»“åº“ç®¡ç†å‘˜æ‰‹åŠ¨åˆå¹¶æ­¤ PRã€‚`);
              }
            }