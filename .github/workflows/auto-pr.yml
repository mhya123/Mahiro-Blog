name: Admin Friend Link Audit

on:
  pull_request_target:
    types: [opened, synchronize, reopened]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - name: å‹é“¾è‡ªåŠ¨åŒ–å®¡æ ¸ä¸åˆå¹¶
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = context.payload.pull_request.number;
            const head_sha = context.payload.pull_request.head.sha;

            // ================= å¸¸é‡å®šä¹‰åŒº =================
            const MY_DOMAINS = ['mahiro.work']; // å¡«ä½ éœ€è¦åŒ¹é…çš„æ ¸å¿ƒä¸»åŸŸåæˆ–å¤šä¸ªåŸŸå

            const LABELS = {
              BASE: 'å‹é“¾ç”³è¯·',
              RUNNING: 'audit-running',
              PASSED: 'audit-passed',
              NEED_FIX: 'need-fix',
              SITE_OK: 'site-ok',
              SITE_ERR: 'site-error',
              AVATAR_OK: 'avatar-ok',
              AVATAR_ERR: 'avatar-error',
              LINK_OK: 'backlink-ok',
              LINK_ERR: 'backlink-error'
            };

            const MSG = {
              PR_MULTI_FILES: 'PR å¿…é¡»ä»…åŒ…å« 1 ä¸ªæ–‡ä»¶çš„å˜æ›´ã€‚',
              PR_PATH_ERR: 'ä¿®æ”¹è·¯å¾„å¿…é¡»ä¸¥æ ¼é™åˆ¶åœ¨ `src/data/friends/` ç›®å½•ä¸‹ï¼Œä¸”æ–‡ä»¶æ‰©å±•åå¿…é¡»æ˜¯ `.json`ã€‚',
              PR_ACTION_ERR: 'åªå…è®¸æ–°å¢ (added) æˆ–ä¿®æ”¹ (modified) æ–‡ä»¶ã€‚',
              JSON_PARSE_ERR: 'JSON è§£æå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æ˜¯å¦ç¬¦åˆè§„èŒƒã€‚',
              JSON_KEY_ERR: 'JSON ç¼ºå°‘å¿…å¡«å­—æ®µï¼Œå¿…é¡»åŒ…å«ï¼šname, avatar, description, url, badgeã€‚',
              BADGE_ERR: 'å­—æ®µæ ¡éªŒæœªé€šè¿‡ï¼šbadge çš„å€¼å¿…é¡»ä¸¥æ ¼å¡«å†™ã€‚å»ºè®®å¡«å†™ "å¥½å‹" æˆ– "å‹æƒ…é“¾æ¥"ã€‚',
              SSRF_BLOCK: 'å®‰å…¨æ‹¦æˆªï¼šç›®æ ‡ URL ç–‘ä¼¼æŒ‡å‘å†…ç½‘æˆ–ä¿ç•™ IPã€‚',
              SUCCESS: `ğŸ‰ **å®¡æ ¸é€šè¿‡ï¼**\n\næ„Ÿè°¢ç”³è¯·ï¼ç³»ç»Ÿå·²æ£€æµ‹åˆ°æœ‰æ•ˆçš„åŒå‘é“¾æ¥å¹¶ç¡®è®¤æ ¼å¼æ— è¯¯ï¼Œç°åœ¨ä¸ºæ‚¨è‡ªåŠ¨æ‰§è¡Œåˆå¹¶ (Squash Merge)ã€‚`,
              REJECT: `æ‚¨å¥½ï¼æ„Ÿè°¢å¯¹æœ¬ç«™çš„å…³æ³¨ã€‚\n\nç”±äºè‡ªåŠ¨åŒ–å®¡æ ¸æœªèƒ½æ£€æµ‹åˆ°æœ‰æ•ˆçš„åé“¾ã€ç«™ç‚¹è®¿é—®å¼‚å¸¸æˆ–æ ¼å¼æœ‰è¯¯ï¼ˆè¯¦æƒ…è¯·è§ä¸Šæ–¹å®¡æ ¸æŠ¥å‘Šï¼‰ï¼Œä¸ºäº†ä¿æŒä»“åº“ PR é˜Ÿåˆ—çš„æ•´æ´ï¼Œç³»ç»Ÿå·²æš‚æ—¶ **å…³é—­** æ­¤ PRã€‚\n\n### ğŸ’¡ æ­£ç¡®çš„ JSON æ ¼å¼å‚è€ƒï¼š\nè¯·ç¡®ä¿æ‚¨æäº¤çš„æ–‡ä»¶å†…å®¹ä¸¥æ ¼ç¬¦åˆä»¥ä¸‹æ ¼å¼ï¼š\n\n\`\`\`json\n{\n  "name": "æ‚¨çš„ç½‘ç«™å",\n  "avatar": "https://æ‚¨çš„å¤´åƒURL",\n  "description": "æ‚¨çš„ç½‘ç«™æè¿°",\n  "url": "https://æ‚¨çš„ç½‘ç«™URL",\n  "badge": "å¥½å‹"\n}\n\`\`\`\n\nè¯·æ‚¨å‚è€ƒä¸Šæ–¹çš„é”™è¯¯æŠ¥å‘Šä¸æ­£ç¡®æ ¼å¼ä¿®æ­£åï¼Œé‡æ–°å¼€å¯æˆ–æäº¤æ–°çš„ PRï¼ŒæœŸå¾…æ‚¨çš„åŠ å…¥ï¼`
            };

            // ================= è¾…åŠ©å‡½æ•° =================
            async function createComment(body) {
              const runUrl = `${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`;
              const footer = `\n\n---\n*ğŸ¤– è¯¥è¯„è®ºç”± Action è‡ªåŠ¨åŒ–å‘é€ï¼Œæ— éœ€å›å¤ã€‚ [æŸ¥çœ‹æ„å»ºæ—¥å¿—](${runUrl})*`;
              await github.rest.issues.createComment({ owner, repo, issue_number: pull_number, body: body + footer });
            }

            async function ensureLabel(name, color = 'ededed') {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({ owner, repo, name, color });
                }
              }
            }

            // ç¼“å­˜å½“å‰æ ‡ç­¾çŠ¶æ€ï¼Œé¿å…æ¯æ¬¡è°ƒç”¨éƒ½é‡æ–° GET
            let _labelCache = null;
            async function getLabelCache() {
              if (!_labelCache) {
                const current = await github.rest.issues.get({ owner, repo, issue_number: pull_number });
                _labelCache = new Set((current.data.labels || []).map(l => l.name));
              }
              return _labelCache;
            }

            async function manageLabels(addList = [], removeList = []) {
              const currentLabels = await getLabelCache();

              for (const name of addList) {
                if (!currentLabels.has(name)) {
                  await ensureLabel(name, name.includes('ok') ? '0e8a16' : (name.includes('error') || name === LABELS.NEED_FIX ? 'd93f0b' : '1d76db'));
                  await github.rest.issues.addLabels({ owner, repo, issue_number: pull_number, labels: [name] });
                  currentLabels.add(name);
                }
              }
              for (const name of removeList) {
                if (currentLabels.has(name)) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: pull_number, name });
                    currentLabels.delete(name);
                  } catch (e) { /* ignore */ }
                }
              }
            }

            function isSafeUrl(urlStr) {
              try {
                const u = new URL(urlStr);
                if (u.protocol !== 'http:' && u.protocol !== 'https:') return false;
                const h = u.hostname;
                if (/^(localhost|127\.|10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|::1)/i.test(h)) return false;
                return true;
              } catch { return false; }
            }

            async function fetchWithTimeout(url, timeoutMs = 10000, { headOnly = false } = {}) {
              const controller = new AbortController();
              const timer = setTimeout(() => controller.abort(), timeoutMs);
              try {
                const res = await fetch(url, {
                  method: headOnly ? 'HEAD' : 'GET',
                  headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },
                  signal: controller.signal,
                  redirect: 'follow'
                });
                const text = headOnly ? '' : await res.text();
                return { ok: res.ok, status: res.status, text };
              } catch (e) {
                return { ok: false, error: e.message };
              } finally {
                clearTimeout(timer);
              }
            }

            // ================= æ ¸å¿ƒæ‰§è¡Œé€»è¾‘ =================
            await manageLabels([LABELS.BASE, LABELS.RUNNING], []);
            const reportData = [];
            let isFailed = false;

            try {
              // 1. è·å– PR æ–‡ä»¶åˆ—è¡¨
              const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number });
              
              if (files.length !== 1) throw new Error(MSG.PR_MULTI_FILES);
              const file = files[0];
              
              if (!file.filename.startsWith('src/data/friends/') || !file.filename.endsWith('.json')) {
                throw new Error(MSG.PR_PATH_ERR);
              }
              if (file.status !== 'added' && file.status !== 'modified') {
                throw new Error(MSG.PR_ACTION_ERR);
              }

              // 2. è¯»å–æ–‡ä»¶å†…å®¹è¿›è¡Œ JSON æ ¼å¼æ£€æŸ¥ï¼ˆä» Fork ä»“åº“è¯»å–ï¼‰
              const prHead = context.payload.pull_request.head;
              const { data: fileData } = await github.rest.repos.getContent({
                owner: prHead.repo.owner.login,
                repo: prHead.repo.name,
                path: file.filename,
                ref: head_sha
              });
              const contentStr = Buffer.from(fileData.content, 'base64').toString('utf-8');
              
              let json;
              try { json = JSON.parse(contentStr); } catch { throw new Error(MSG.JSON_PARSE_ERR); }

              const requiredKeys = ['name', 'avatar', 'description', 'url', 'badge'];
              const missingKeys = requiredKeys.filter(k => !json[k] || typeof json[k] !== 'string');
              if (missingKeys.length > 0) throw new Error(`${MSG.JSON_KEY_ERR} ç¼ºå¤±: ${missingKeys.join(', ')}`);
              
              // æ”¾å®½ä¸€ç‚¹å¯¹ badge çš„é™åˆ¶ï¼Œå¯ä»¥æ”¹æˆæ‚¨çš„ç‰¹å®šå€¼å¦‚æœéœ€è¦
              if (!json.badge.trim()) {
                throw new Error(MSG.BADGE_ERR);
              }
              
              reportData.push({ item: 'JSON æ ¼å¼', status: 'âœ… é€šå…³', detail: 'å­—æ®µæ ¡éªŒå®Œæ•´ä¸”è§„èŒƒ' });

              // 3. å®‰å…¨é˜²æŠ¤ SSRF
              if (!isSafeUrl(json.url) || !isSafeUrl(json.avatar)) {
                throw new Error(MSG.SSRF_BLOCK);
              }

              // 4. å¤´åƒè¿é€šæ€§æ£€æŸ¥ï¼ˆHEAD è¯·æ±‚ï¼Œé¿å…ä¸‹è½½å¤§å›¾ç‰‡ï¼‰
              const avatarRes = await fetchWithTimeout(json.avatar, 10000, { headOnly: true });
              if (avatarRes.ok) {
                reportData.push({ item: 'å¤´åƒè¿é€šæ€§', status: 'âœ… æ­£å¸¸', detail: `çŠ¶æ€ç : ${avatarRes.status}` });
                await manageLabels([LABELS.AVATAR_OK]);
              } else {
                isFailed = true;
                reportData.push({ item: 'å¤´åƒè¿é€šæ€§', status: 'âŒ å¤±è´¥', detail: avatarRes.error || `çŠ¶æ€ç : ${avatarRes.status}` });
                await manageLabels([LABELS.AVATAR_ERR]);
              }

              // 5. ç«™ç‚¹ä¸åé“¾è¿é€šæ€§æ£€æŸ¥
              const siteRes = await fetchWithTimeout(json.url);
              if (siteRes.ok) {
                reportData.push({ item: 'ç«™ç‚¹è¿é€šæ€§', status: 'âœ… æ­£å¸¸', detail: `çŠ¶æ€ç : ${siteRes.status}` });
                await manageLabels([LABELS.SITE_OK]);

                // åé“¾åˆ†æ
                const html = siteRes.text;
                let hasBacklink = false;
                let isNofollow = false;

                // åŠ¨æ€æ„é€ æ­£åˆ™åŒ¹é…ä»»ä½•æŒ‡å®šçš„ä¿¡ä»»åŸŸå
                const domainPattern = MY_DOMAINS.map(d => d.replace(/\./g, '\\.')).join('|');
                const linkRegex = new RegExp(`<a[^>]*href\\s*=\\s*["'][^"']*(${domainPattern})[^"']*["'][^>]*>`, 'gi');
                
                let match;
                while ((match = linkRegex.exec(html)) !== null) {
                  hasBacklink = true;
                  if (match[0].toLowerCase().includes('rel="nofollow"')) {
                    isNofollow = true;
                  }
                }

                if (hasBacklink) {
                  const nofollowTag = isNofollow ? ' *(æ³¨: æ£€æµ‹åˆ° nofollow å±æ€§)*' : '';
                  reportData.push({ item: 'åé“¾æ£€æµ‹', status: 'âœ… å·²æ‰¾åˆ°', detail: `åœ¨æºç ä¸­å‘ç°æœ¬ç«™é“¾æ¥${nofollowTag}` });
                  await manageLabels([LABELS.LINK_OK]);
                } else {
                  isFailed = true;
                  reportData.push({ item: 'åé“¾æ£€æµ‹', status: 'âŒ ç¼ºå¤±', detail: 'æœªåœ¨å¯¹æ–¹é¡µé¢æ‰¾åˆ°æŒ‡å‘æœ¬ç«™çš„è¶…é“¾æ¥' });
                  await manageLabels([LABELS.LINK_ERR]);
                }

              } else {
                isFailed = true;
                reportData.push({ item: 'ç«™ç‚¹è¿é€šæ€§', status: 'âŒ å¤±è´¥', detail: siteRes.error || `çŠ¶æ€ç : ${siteRes.status}` });
                reportData.push({ item: 'åé“¾æ£€æµ‹', status: 'âš ï¸ è·³è¿‡', detail: 'ç«™ç‚¹æ— æ³•è®¿é—®ï¼Œè·³è¿‡åé“¾æ£€æµ‹' });
                await manageLabels([LABELS.SITE_ERR, LABELS.LINK_ERR]);
              }

            } catch (err) {
              isFailed = true;
              reportData.push({ item: 'è‡´å‘½é”™è¯¯/å‰ç½®æ£€æŸ¥', status: 'âŒ æ‹¦æˆª', detail: err.message });
            }

            // ================= æŠ¥å‘Šç”Ÿæˆä¸æœ€ç»ˆåŠ¨ä½œ =================
            let markdownTable = `### ï¿½ è‡ªåŠ¨åŒ–å®¡æ ¸æŠ¥å‘Š\n\n| æ£€æŸ¥é¡¹ç›® | çŠ¶æ€ | è¯¦ç»†è¯´æ˜ |\n| :--- | :--- | :--- |\n`;
            reportData.forEach(r => { markdownTable += `| **${r.item}** | ${r.status} | ${r.detail} |\n`; });

            if (isFailed) {
              await manageLabels([LABELS.NEED_FIX], [LABELS.RUNNING]);
              await createComment(`${markdownTable}\n\n---\n\n${MSG.REJECT}`);
              // å¼ºåˆ¶å…³é—­ PR
              await github.rest.pulls.update({ owner, repo, pull_number, state: 'closed' });
              core.setFailed('è‡ªåŠ¨åŒ–å®¡æ ¸æœªé€šè¿‡ï¼Œå·²å…³é—­ PRã€‚');
            } else {
              await manageLabels([LABELS.PASSED], [LABELS.RUNNING]);
              await createComment(`${markdownTable}\n\n---\n\n${MSG.SUCCESS}`);
              // æ‰§è¡Œè‡ªåŠ¨ Squash Mergeï¼ˆå¸¦å…œåº•ï¼‰
              try {
                await github.rest.pulls.merge({ owner, repo, pull_number, merge_method: 'squash' });
              } catch (mergeErr) {
                await createComment(`âš ï¸ è‡ªåŠ¨åˆå¹¶å¤±è´¥: ${mergeErr.message}\n\nè¯·ä»“åº“ç®¡ç†å‘˜æ‰‹åŠ¨åˆå¹¶æ­¤ PRã€‚`);
              }
            }
