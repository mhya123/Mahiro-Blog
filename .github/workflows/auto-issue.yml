name: Admin Friend Link Issue Audit

on:
  issues:
    types: [opened, edited]

permissions:
  contents: read
  issues: write

jobs:
  audit-issue:
    runs-on: ubuntu-latest
    if: contains(github.event.issue.title, 'å‹é“¾ç”³è¯·')
    steps:
      - name: å‹é“¾ Issue è‡ªåŠ¨åŒ–å®¡æ ¸ä¸Ž WAF æ‹¦æˆªè½¬å®¡
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.issue.number;
            const issue_body = context.payload.issue.body || '';

            // ================= å¸¸é‡å®šä¹‰åŒº =================
            const MY_DOMAINS = ['mahiro.work'];

            const LABELS = {
              BASE: 'å‹é“¾ç”³è¯·',
              RUNNING: 'å®¡æ ¸ä¸­',
              PASSED: 'å®¡æ ¸é€šè¿‡',
              NEEDS_MANUAL: 'éœ€äººå·¥å®¡æ ¸',
              NEED_FIX: 'å¾…ä¿®æ”¹',
              SITE_OK: 'ç«™ç‚¹æ­£å¸¸',
              SITE_ERR: 'ç«™ç‚¹å¼‚å¸¸',
              AVATAR_OK: 'å¤´åƒæ­£å¸¸',
              AVATAR_ERR: 'å¤´åƒå¼‚å¸¸',
              LINK_OK: 'åé“¾æœ‰æ•ˆ',
              LINK_ERR: 'åé“¾ç¼ºå¤±'
            };

            const MSG = {
              JSON_MISSING_ERR: 'æœªåœ¨ Issue ä¸­æ‰¾åˆ°åˆæ³•çš„ JSON ä»£ç å—ã€‚è¯·ç¡®ä¿æ‚¨çš„ JSON æ•°æ®åŒ…è£¹åœ¨ ```json å’Œ ``` ä¹‹é—´ã€‚',
              JSON_PARSE_ERR: 'JSON è§£æžå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼æ˜¯å¦ç¬¦åˆå®Œå…¨æ­£ç¡®çš„ JSON è§„èŒƒï¼ˆå¦‚ï¼šä¸èƒ½æœ‰å•å¼•å·ï¼Œä¸èƒ½ç¼ºå°‘é€—å·ç­‰ï¼‰ã€‚',
              JSON_KEY_ERR: 'JSON ç¼ºå°‘å¿…å¡«å­—æ®µï¼Œå¿…é¡»åŒ…å«ï¼šname, avatar, description, url, badgeã€‚',
              BADGE_ERR: 'å­—æ®µæ ¡éªŒæœªé€šè¿‡ï¼šbadge çš„å€¼å¿…é¡»ä¸¥æ ¼å¡«å†™ã€‚ä»…å…è®¸å¡«å†™ "å¥½å‹", "å‹æƒ…" æˆ– "å‹æƒ…é“¾æŽ¥"ã€‚',
              SSRF_BLOCK: 'å®‰å…¨æ‹¦æˆªï¼šç›®æ ‡ URL ç–‘ä¼¼æŒ‡å‘å†…ç½‘æˆ–ä¿ç•™ IPã€‚',
              SUCCESS: `ðŸŽ‰ **é¢„å®¡é€šè¿‡ï¼**\n\næ„Ÿè°¢æ‚¨æäº¤çš„å‹é“¾ç”³è¯·ï¼ç³»ç»Ÿå·²æˆåŠŸæ£€æµ‹åˆ°æœ¬ç«™åŒå‘é“¾æŽ¥å¹¶ç¡®è®¤å…¨éƒ¨ä¿¡æ¯å¯è¾¾ã€‚\n\nç”±äºŽ Issue æ— æ³•è‡ªåŠ¨ç”Ÿæˆä»£ç æ–‡ä»¶ï¼Œæˆ‘å·²æ‰“ä¸Š \`å®¡æ ¸é€šè¿‡\` æ ‡ç­¾ã€‚ä»“åº“ç®¡ç†å‘˜ç¨åŽä¼šäººå·¥å°†æ‚¨çš„ç½‘ç«™æ·»åŠ å…¥åº“ï¼Œè¯·è€å¿ƒç­‰å¾…ã€‚`,
              NEEDS_MANUAL: `ðŸ¤– **è‡ªåŠ¨åŒ–åˆå®¡é‡åˆ°äº†å›°éš¾ (éœ€äººå·¥å¹²é¢„)**\n\næ‚¨å¥½ï¼æ„Ÿè°¢æäº¤ç”³è¯·ã€‚ç”±äºŽè‡ªåŠ¨åŒ–å®¡æ ¸å·¥å…·ï¼ˆæ— å¤´çˆ¬è™«ï¼‰åœ¨è¯•å›¾è®¿é—®æ‚¨çš„ç«™ç‚¹ä»¥æ£€æŸ¥è¿žé€šæ€§æˆ–åé“¾æ—¶ï¼Œé­åˆ°äº†ç½‘ç«™å®‰å…¨ç­–ç•¥ï¼ˆå¯èƒ½ä¸ºé˜²ç«å¢™ WAFã€é˜²çˆ¬è™«ç­–ç•¥æˆ–æµ·å¤–æ‹¦æˆªï¼‰çš„æ‹’ç»ã€‚\n\nä½†è¿™ **å®Œå…¨æ­£å¸¸**ï¼ç³»ç»Ÿå·²è‡ªåŠ¨ä¸ºæ‚¨æ‰“ä¸Š \`éœ€äººå·¥å®¡æ ¸\` æ ‡ç­¾ï¼Œå¹¶è‡ªåŠ¨é€šçŸ¥äº†ä»“åº“ç®¡ç†å‘˜ã€‚\n\nç®¡ç†å‘˜å°†åœ¨è¿‘æœŸé€šè¿‡æ™®é€šæµè§ˆå™¨æ‰‹åŠ¨è®¿é—®æ‚¨çš„ç½‘ç«™å¤æ ¸ç¡®è®¤ï¼Œè¯·è€å¿ƒç­‰å¾…ï¼`,
              REJECT: `æ‚¨å¥½ï¼æ„Ÿè°¢å¯¹æœ¬ç«™çš„å…³æ³¨ã€‚\n\næ‚¨æäº¤çš„å†…å®¹å­˜åœ¨ **ä¸¥é‡çš„ä¸å¯æŠ—æ‹’çš„æ ¼å¼é—®é¢˜**ï¼Œå¯¼è‡´è‡ªåŠ¨åŒ–å®¡æ ¸ä¸­æ–­ï¼ˆè¯¦æƒ…è¯·è§ä¸Šæ–¹å®¡æ ¸æŠ¥å‘Šï¼‰ã€‚é‰´äºŽæ­¤ï¼Œç³»ç»Ÿå·²æš‚æ—¶ **å…³é—­** æ­¤ Issueã€‚\n\n### ðŸ’¡ ä¿®æ”¹å»ºè®®ï¼š\nè¯·å‚è€ƒä¸Šæ–¹æŠ¥å‘Šä¿®æ­£æ‚¨çš„é…ç½®ã€‚**å®ŒæˆåŽï¼Œè¯·æ‚¨åœ¨ä»“åº“é‡æ–°æäº¤ä¸€ä¸ªæ–°çš„ Issue è¿›è¡Œç”³è¯·ï¼Œä¸è¦åœ¨æ­¤ Issue å¤„ä¿®æ”¹ï¼**`
            };

            // ================= è¾…åŠ©å‡½æ•° =================
            async function createComment(body) {
              const runUrl = `${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`;
              const footer = `\n\n---\n*ðŸ¤– è¯¥è¯„è®ºç”± Action è‡ªåŠ¨åŒ–å‘é€ï¼Œæ— éœ€å›žå¤ã€‚ [æŸ¥çœ‹æž„å»ºæ—¥å¿—](${runUrl})*`;
              await github.rest.issues.createComment({ owner, repo, issue_number, body: body + footer });
            }

            async function ensureLabel(name, color = 'ededed') {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  await github.rest.issues.createLabel({ owner, repo, name, color });
                }
              }
            }

            function getLabelColor(name) {
              const greenLabels = ['å®¡æ ¸é€šè¿‡', 'ç«™ç‚¹æ­£å¸¸', 'å¤´åƒæ­£å¸¸', 'åé“¾æœ‰æ•ˆ'];
              const redLabels = ['å¾…ä¿®æ”¹', 'ç«™ç‚¹å¼‚å¸¸', 'å¤´åƒå¼‚å¸¸', 'åé“¾ç¼ºå¤±'];
              const orangeLabels = ['éœ€äººå·¥å®¡æ ¸'];
              if (greenLabels.includes(name)) return '0e8a16';
              if (redLabels.includes(name)) return 'd93f0b';
              if (orangeLabels.includes(name)) return 'd93f0b'; // orange/red
              return '1d76db';
            }

            let _labelCache = null;
            async function getLabelCache() {
              if (!_labelCache) {
                const current = await github.rest.issues.get({ owner, repo, issue_number });
                _labelCache = new Set((current.data.labels || []).map(l => l.name));
              }
              return _labelCache;
            }

            async function manageLabels(addList = [], removeList = []) {
              const currentLabels = await getLabelCache();

              for (const name of addList) {
                if (!currentLabels.has(name)) {
                  await ensureLabel(name, getLabelColor(name));
                  await github.rest.issues.addLabels({ owner, repo, issue_number, labels: [name] });
                  currentLabels.add(name);
                }
              }
              for (const name of removeList) {
                if (currentLabels.has(name)) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number, name });
                    currentLabels.delete(name);
                  } catch (e) { /* ignore */ }
                }
              }
            }

            function isSafeUrl(urlStr) {
              try {
                const u = new URL(urlStr);
                if (u.protocol !== 'http:' && u.protocol !== 'https:') return false;
                const h = u.hostname;
                if (/^(localhost|127\.|10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|::1)/i.test(h)) return false;
                return true;
              } catch { return false; }
            }

            async function fetchWithTimeout(url, timeoutMs = 10000, { headOnly = false } = {}) {
              const controller = new AbortController();
              const timer = setTimeout(() => controller.abort(), timeoutMs);
              try {
                const res = await fetch(url, {
                  method: headOnly ? 'HEAD' : 'GET',
                  headers: { 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36' },
                  signal: controller.signal,
                  redirect: 'follow'
                });
                const text = headOnly ? '' : await res.text();
                return { ok: res.ok, status: res.status, text };
              } catch (e) {
                return { ok: false, error: e.message };
              } finally {
                clearTimeout(timer);
              }
            }

            // ================= æ ¸å¿ƒæ‰§è¡Œé€»è¾‘ =================
            await manageLabels([LABELS.BASE, LABELS.RUNNING], []);
            const reportData = [];
            
            // è‡´å‘½æ ¼å¼é”™è¯¯ï¼ˆå¼•å‘å…³é—­ï¼‰
            let fatalError = false;
            // è¿žé€šæ€§/åˆ®å‰Šå—é˜»ï¼ˆä»…è½¬äººå·¥ï¼Œä¸å…³é—­ï¼‰
            let blockedByWaf = false;

            try {
              // 1. æå– JSON ä»£ç å—
              const jsonMatch = issue_body.match(/```json\s+([\s\S]+?)\s+```/i);
              if (!jsonMatch || !jsonMatch[1]) {
                throw new Error(MSG.JSON_MISSING_ERR);
              }
              
              const contentStr = jsonMatch[1].trim();
              
              let json;
              try { json = JSON.parse(contentStr); } catch { throw new Error(MSG.JSON_PARSE_ERR); }

              const requiredKeys = ['name', 'avatar', 'description', 'url', 'badge'];
              const missingKeys = requiredKeys.filter(k => !json[k] || typeof json[k] !== 'string');
              if (missingKeys.length > 0) throw new Error(`${MSG.JSON_KEY_ERR} ç¼ºå¤±: ${missingKeys.join(', ')}`);
              
              const allowedBadges = ['å¥½å‹', 'å‹æƒ…', 'å‹æƒ…é“¾æŽ¥'];
              if (!allowedBadges.includes(json.badge.trim())) {
                throw new Error(MSG.BADGE_ERR);
              }
              
              reportData.push({ item: 'JSON æ ¼å¼', status: 'âœ… é€šå…³', detail: 'å­—æ®µæ ¡éªŒå®Œæ•´ä¸”è§„èŒƒ' });

              // 2. å®‰å…¨é˜²æŠ¤ SSRF
              if (!isSafeUrl(json.url) || !isSafeUrl(json.avatar) || (json.backlink && !isSafeUrl(json.backlink))) {
                throw new Error(MSG.SSRF_BLOCK);
              }

              // 3. ç½‘ç»œå¹¶å‘æµ‹è¯•
              const fetchTasks = [
                fetchWithTimeout(json.avatar, 10000, { headOnly: true }), // [0] æµ‹å¤´åƒ
                fetchWithTimeout(json.url)                                // [1] æµ‹ä¸»ç«™å­˜æ´»
              ];

              const hasCustomBacklink = typeof json.backlink === 'string' && json.backlink.trim() !== '';
              if (hasCustomBacklink) {
                fetchTasks.push(fetchWithTimeout(json.backlink.trim()));  // [2] åŽ»ä¸“å±žå‹é“¾é¡µæ‰’åé“¾
              }

              const results = await Promise.all(fetchTasks);
              const avatarRes = results[0];
              const siteRes = results[1];
              
              const backlinkRes = hasCustomBacklink ? results[2] : siteRes;
              const checkTargetUrl = hasCustomBacklink ? json.backlink.trim() : json.url;

              // éªŒè¯å¤´åƒ
              if (avatarRes.ok) {
                reportData.push({ item: 'å¤´åƒè¿žé€šæ€§', status: 'âœ… æ­£å¸¸', detail: `çŠ¶æ€ç : ${avatarRes.status}` });
                await manageLabels([LABELS.AVATAR_OK]);
              } else {
                blockedByWaf = true;
                reportData.push({ item: 'å¤´åƒè¿žé€šæ€§', status: 'âš ï¸ ç–‘ä¼¼æ‹¦æˆª', detail: avatarRes.error || `è¯·æ±‚å—é˜»ï¼ŒçŠ¶æ€ç : ${avatarRes.status} (WAF?)` });
                await manageLabels([LABELS.AVATAR_ERR]);
              }

              // éªŒè¯ç«™ç‚¹
              if (siteRes.ok) {
                reportData.push({ item: 'ç«™ç‚¹è¿žé€šæ€§', status: 'âœ… æ­£å¸¸', detail: `çŠ¶æ€ç : ${siteRes.status}` });
                await manageLabels([LABELS.SITE_OK]);
              } else {
                blockedByWaf = true;
                reportData.push({ item: 'ç«™ç‚¹è¿žé€šæ€§', status: 'âš ï¸ ç–‘ä¼¼æ‹¦æˆª', detail: siteRes.error || `è¯·æ±‚å—é˜»ï¼ŒçŠ¶æ€ç : ${siteRes.status} (WAF?)` });
                await manageLabels([LABELS.SITE_ERR]);
              }

              // éªŒè¯åé“¾
              if (backlinkRes.ok) {
                const html = backlinkRes.text;
                let hasBacklink = false;
                let isNofollow = false;

                const domainPattern = MY_DOMAINS.map(d => d.replace(/\./g, '\\.')).join('|');
                const linkRegex = new RegExp(`<a[^>]*href\\s*=\\s*["'][^"']*(${domainPattern})[^"']*["'][^>]*>`, 'gi');
                
                let match;
                while ((match = linkRegex.exec(html)) !== null) {
                  hasBacklink = true;
                  if (match[0].toLowerCase().includes('rel="nofollow"')) {
                    isNofollow = true;
                  }
                }

                if (hasBacklink) {
                  const nofollowTag = isNofollow ? ' *(æ³¨: æ£€æµ‹åˆ° nofollow å±žæ€§)*' : '';
                  reportData.push({ item: 'åé“¾æ£€æµ‹', status: 'âœ… å·²æ‰¾åˆ°', detail: `åœ¨ [ç›®æ ‡é¡µé¢](${checkTargetUrl}) ä¸­å‘çŽ°æœ¬ç«™é“¾æŽ¥${nofollowTag}` });
                  await manageLabels([LABELS.LINK_OK]);
                } else {
                  blockedByWaf = true;
                  reportData.push({ item: 'åé“¾æ£€æµ‹', status: 'âš ï¸ æœªæ‰¾åˆ°', detail: `æœªåœ¨ [ç›®æ ‡é¡µé¢](${checkTargetUrl}) æå–åˆ°æŒ‡å‘æœ¬ç«™çš„è¶…é“¾æŽ¥ï¼Œå¯èƒ½è¢«å®‰å…¨éªŒè¯é¡µé˜»éš”` });
                  await manageLabels([LABELS.LINK_ERR]);
                }
              } else {
                blockedByWaf = true;
                reportData.push({ item: 'åé“¾æ£€æµ‹', status: 'âš ï¸ ç–‘ä¼¼æ‹¦æˆª', detail: `æ— æ³•ä½œä¸ºçˆ¬è™«è®¿é—®æ‰’å–åé“¾çš„ç½‘é¡µèµ„æºï¼ŒçŠ¶æ€ç : ${backlinkRes.status}` });
                await manageLabels([LABELS.LINK_ERR]);
              }

            } catch (err) {
              fatalError = true;
              reportData.push({ item: 'å‰ç½®æ ¡éªŒæ‹¦æˆª', status: 'âŒ æœªé€šè¿‡', detail: err.message });
            }

            // ================= æŠ¥å‘Šç”Ÿæˆä¸Žæœ€ç»ˆåŠ¨ä½œ =================
            let markdownTable = `### ðŸ” è‡ªåŠ¨åŒ–å®¡æ ¸æŠ¥å‘Š\n\n| æ£€æŸ¥é¡¹ç›® | çŠ¶æ€ | è¯¦ç»†è¯´æ˜Ž |\n| :--- | :--- | :--- |\n`;
            reportData.forEach(r => { markdownTable += `| **${r.item}** | ${r.status} | ${r.detail} |\n`; });

            // æ— è®ºå¦‚ä½•ï¼Œåªè¦è¿›è¡Œåˆ°è¿™é‡Œï¼Œéƒ½è¦ä¿è¯ Issue æ˜¯å¼€å¯çš„ï¼ˆé™¤äº†ä¸¥é‡æ ¼å¼é”™è¯¯å¼ºåˆ¶å…³åœï¼‰
            const ensureOpenIssue = async () => {
              const currentIssue = await github.rest.issues.get({ owner, repo, issue_number });
              if (currentIssue.data.state === 'closed') {
                 await github.rest.issues.update({ owner, repo, issue_number, state: 'open' });
              }
            };

            if (fatalError) {
              // ä¸¥é‡çš„æ ¼å¼é—®é¢˜ (JSONæ²¡å†™å¯¹, SSRFæ³¨å…¥) -> æ‹’ç»å¹¶å…³é—­
              await manageLabels([LABELS.NEED_FIX], [LABELS.RUNNING]);
              await createComment(`${markdownTable}\n\n---\n\n${MSG.REJECT}`);
              await github.rest.issues.update({ owner, repo, issue_number, state: 'closed' });
              core.setFailed('å‰ç½®å®‰å…¨/æ ¼å¼å®¡æ ¸æœªé€šè¿‡ï¼Œå·²å…³é—­ Issueã€‚');
            } else if (blockedByWaf) {
              // è¢« WAF ç›¾æ‹¦æˆªæˆ–åªæ˜¯è½»åº¦æ²¡æ‰«å‡º -> æ ‡æ³¨äººå·¥ï¼Œä¸å…³é—­
              await ensureOpenIssue();
              await manageLabels([LABELS.NEEDS_MANUAL], [LABELS.RUNNING, LABELS.PASSED, LABELS.NEED_FIX]);
              await createComment(`${markdownTable}\n\n---\n\n${MSG.NEEDS_MANUAL}`);
              core.notice('é­é‡è¿žé€šæ€§éšœç¢ (ç–‘ä¼¼ WAF é˜²æŠ¤)ï¼Œå·²æŒ‚èµ·å¹¶è½¬äº¤äººå·¥å¤æ ¸ã€‚');
            } else {
              // å®Œç¾Žå‘½ä¸­ -> ç›´æŽ¥é€šè¿‡
              await ensureOpenIssue();
              await manageLabels([LABELS.PASSED], [LABELS.RUNNING, LABELS.NEEDS_MANUAL, LABELS.NEED_FIX]);
              await createComment(`${markdownTable}\n\n---\n\n${MSG.SUCCESS}`);
            }
